-----------------------------
--- side scroller with physics integration
--- day 4 - tues - 11/4
-----------------------------
W = love.graphics.getWidth()
H = love.graphics.getHeight()

globals = {}
gameState = {}
gameObjects = {}
assets = {}

require("physicshelper")

function love.load()
  globals.TILESIZE = 32
  globals.HALFTILESIZE = globals.TILESIZE * 0.5
  globals.METERSCALE = globals.TILESIZE * 0.5
  globals.GRAVITY = 9.81

  assets.ground = love.graphics.newImage("assets/Dirt-Grass-PT.png")
  assets.enemy = love.graphics.newImage("assets/Crate.png")

  gameState.bgcolor = {1, 1, 1}
  gameState.drawHitboxes = false

  gameObjects.player = {}
  gameObjects.enemies = {}
  gameObjects.platforms = {}

  gameState.msg = "TEST"

  gameState.camera_offset = {x = 0, y = 0}

  love.physics.setMeter(globals.METERSCALE)

  world = love.physics.newWorld(0, globals.GRAVITY*globals.METERSCALE, true)
  world:setCallbacks(beginContact, endContact, preSolve, postSolve)


  gameObjects.player = makeObject("player", 5, 2, "dynamic",assets.enemy)
  gameObjects.player.body:setFixedRotation(true)
  -- TODO: fix this!
  gameObjects.player.platformCounter = 0

  -- SET UP PLAYER SPRITE SHEET
  gameObjects.player.frameNum = 1

  gameObjects.player.image = love.graphics.newImage("assets/HaloMasterChiefSheet.png")

  gameObjects.player.quads = {}

  for i = 1, 8 do
    -- each tile in this sprite sheet is 96x96
    gameObjects.player.quads[i] = love.graphics.newQuad((i-1)*96, 0, 96, 96, gameObjects.player.image:getWidth(), gameObjects.player.image:getHeight())
  end


  -----------------------------------
  -- MAKE ENEMIES
  for i = 1,10 do
    gameObjects.enemies[i] = makeObject("enemy", i*5, 3,"dynamic",assets.enemy)
    gameObjects.enemies[i].fixture:setRestitution(1)
  end

  -----------------------------------
  -- MAKE PLATFORMS
  for i = 1, 30 do
    gameObjects.platforms[i] = makePlatform(i, 10,  {1,1,1}, assets.ground)
    gameObjects.platforms[i].fixture:setFriction(0.8)
  end

  gameObjects.platforms[31] = makePlatform(3,3, {.2, .2, 1.0, 0.5}, assets.ground)
  gameObjects.platforms[31].fixture:setFriction(0.1)
end

local function draw_player()
  love.graphics.setColor(1,1,1,1)
  local tmp_x, tmp_y = gameObjects.player.body:getPosition()
  love.graphics.draw(gameObjects.player.image, gameObjects.player.quads[gameObjects.player.frameNum],
    tmp_x, tmp_y, gameObjects.player.body:getAngle(), 0.5, 0.5, 48, 48)

  if(gameState.drawHitboxes) then
    love.graphics.setColor(1,0,0,0.5)
    love.graphics.polygon("fill", gameObjects.player.body:getWorldPoints(
                              gameObjects.player.shape:getPoints()))
  end
end


function love.draw()
  local p_x, p_y = gameObjects.player.body:getPosition()

  if(p_x < (gameState.camera_offset.x + 0.3*W)) then
    gameState.camera_offset.x = gameState.camera_offset.x - ((gameState.camera_offset.x + 0.3*W)- p_x)
  elseif(p_x > (gameState.camera_offset.x + 0.6*W)) then
    gameState.camera_offset.x = gameState.camera_offset.x + (p_x - (gameState.camera_offset.x + 0.6*W))
  end

  -- love.graphics.translate(-p_x + 400, -p_y + 300)
  love.graphics.translate(-gameState.camera_offset.x, -gameState.camera_offset.y)

  -- love.graphics.scale( 2, 2 )
  love.graphics.setBackgroundColor(gameState.bgcolor)

  --platforms
  for i = 1, #(gameObjects.platforms) do
    gameObjects.platforms[i].draw()
  end

  -- "BOX"
  love.graphics.setColor({1,0,1,1})
  for i = 1, #gameObjects.enemies do

  gameObjects.enemies[i].draw()
    -- love.graphics.polygon("fill", gameObjects.enemies[i].body:getWorldPoints(
    --   gameObjects.enemies[i].shape:getPoints()))

  end

  -- PLAYER
  draw_player()

  love.graphics.setColor(0,0,0)
  love.graphics.printf(gameState.msg, 0,0, W, "center")

end



function love.update(dt)
  world:update(dt) -- this puts the world into motion

  if(love.keyboard.isDown("h")) then
    gameState.drawHitboxes = not gameState.drawHitboxes
  end

  -- TODO: get input, update objects, good stuff
  -- here we are going to create some keyboard events
  -- press the right arrow key to push the ball to the right
  if love.keyboard.isDown("right") then
    gameObjects.player.body:applyForce(400, 0)
  -- press the left arrow key to push the ball to the left
  elseif love.keyboard.isDown("left") then
    gameObjects.player.body:applyForce(-400, 0)
  -- JUMP CHECKING
  elseif love.keyboard.isDown("space") and (gameObjects.player.platformCounter > 0) then
    gameObjects.player.body:applyLinearImpulse(0, -150)
  -- press the up arrow key to set the ball in the air
  elseif love.keyboard.isDown("up") then
    gameObjects.player.body:setPosition(650/2, 650/12)
    -- we must set the velocity to zero to prevent a potentially large
    -- velocity generated by the change in position
    gameObjects.player.body:setLinearVelocity(0, 0)
    gameObjects.player.body:setAngularVelocity(0)
  end
end

function checkTwoThings(a,b,thingOne,thingTwo)
  if (a:getUserData() == thingOne and b:getUserData() == thingTwo) then
    return true
  elseif (b:getUserData() == thingOne and a:getUserData() == thingTwo) then
    return true
  end
  return false
end

function beginContact(a, b, coll)
	-- msg =  a:getUserData() .. " hit " .. b:getUserData() .. "\n" .. msg
  if(checkTwoThings(a,b,"player","platform")) then
    gameObjects.player.platformCounter = gameObjects.player.platformCounter + 1
  end
end

function endContact(a, b, coll)
  if(checkTwoThings(a,b,"player","platform")) then
    gameObjects.player.platformCounter = gameObjects.player.platformCounter - 1
  end
end

function preSolve(a, b, coll)

end

function postSolve(a, b, coll, normalimpulse, tangentimpulse)
  -- if(checkTwoThings(a,b,"player","enemy")) then
  --   if(a==player) then
  --     local dx = player.x - b.x
  --     local dy = player.y - b.y
  --     player.body:applyLinearImpulse(1000*dx, 1000*dy)
  --   end
  -- end
end
